void GuideMe::updateEdge(unordered_map<string, vector<Edge>>& graph) {
  
    int newCost;
    string transportation;
    char choice;
    do {
        
        string source, destination;
        cout << "Enter source city: ";
        cin >> source;
        cout << "Enter destination city: ";
        cin >> destination;
        cout << "Enter the transportation type you want to update : ";
        cin >> transportation;
        cout << "Enter the updated price for " << transportation << " from " << source << " to " << destination << ": ";
        cin >> newCost;
        updateEdgehelper(graph, source, destination, transportation, newCost);
        updateEdgehelper(graph, destination, source, transportation, newCost);
        cout << "Do you want to update another transportation ? (y/n): ";
        cin >> choice;


    } while ((choice == 'y' || choice == 'Y'));
   

}

void GuideMe::updateEdgehelper(unordered_map<string, vector<Edge>>& graph, const string& source, const string& destination, string transportation, int newCost) {

  
    auto sourceIt = graph.find(source);
    if (sourceIt == graph.end()) {
        cerr << "Error: Source city '" << source << "' not found." << endl;
        return;
    }

    // Find the edge corresponding to the destination and source
    vector<Edge>& edges = sourceIt->second;
    auto edgeIt = edges.end();  // Initialize edgeIt to the end iterator as a default value

    // Iterate over the edges vector
    for (auto it = edges.begin(); it != edges.end(); ++it) {
        // Check if the destination of the current Edge matches the provided destination
        if (it->destination == destination) {
            // If found, update edgeIt and break out of the loop
            edgeIt = it;
            break;
        }
    }


    if (edgeIt == edges.end()) {
        cerr << "Error: Destination city '" << destination << "' not reachable from '" << source << "'." << endl;
        return;
    }

    // Update the corresponding transportation price for the specified destination
    auto& transportationPrices = edgeIt->transportationPrices;
    if (transportationPrices.find(transportation) != transportationPrices.end()) {
        transportationPrices[transportation] = newCost;
        cout << transportation << " price from " << source << " to " << destination << " updated successfully." << endl;
    }
    else {
        cerr << "Error: Transportation type '" << transportation << "' not found for the specified destination." << endl;
    }
}

void GuideMe::deleteEdge(unordered_map<string, vector<Edge>>& graph) {
    string source, destination;
    cout << "Enter source city: ";
    cin >> source;
    cout << "Enter destination city: ";
    cin >> destination;


    vector<string> transportations;
    char choice;
    do {
        string transportation;
        cout << "Enter transportation type to delete: ";
        cin >> transportation;
        transportations.push_back(transportation);
        cout << "Do you want to delete another transportation type? (y/n): ";
        cin >> choice;
    } while (choice == 'y' || choice == 'Y');

    for (const auto& transportation : transportations) {
        deleteEdgehelper(graph, source, destination, transportation);
        deleteEdgehelper(graph, destination, source, transportation);
    }
}


void GuideMe::deleteEdgehelper(unordered_map<string, vector<Edge>>& graph, const string& source, const string& destination, const string& transportation) {
    auto it = graph.find(source);
    if (it != graph.end()) {
        vector<Edge>& edges = it->second;
        for (auto& edge : edges) {
            if (edge.destination == destination) {
                auto priceIt = edge.transportationPrices.find(transportation);
                if (priceIt != edge.transportationPrices.end()) {
                    edge.transportationPrices.erase(priceIt);
                    cout << "Transportation type '" << transportation << "' deleted successfully from edge " << source << " to " << destination << endl;
                    return;
                }
                else {

                    cout << "Error: Edge not found or specified transportation type not present!" << endl;
                    deleteEdge(graph);

                }
            }
        }
    }
    else {

        cout << "Error: Edge not found or specified transportation type not present!" << endl;
        deleteEdge(graph);

    }

    //// Prompt user for input again until valid inputs are provided
    //string newSource, newDestination, newTransportation;
    //cout << "Enter correct source: ";
    //cin >> newSource;
    //cout << "Enter correct destination: ";
    //cin >> newDestination;
    //vector<string> transportations;

    //char choice;
    //do {
    //   
    //    cout << "Enter transportation type to delete: ";
    //    cin >> newTransportation;
    //    transportations.push_back(newTransportation);
    //    cout << "Do you want to delete another transportation type? (y/n): ";
    //    cin >> choice;
    //} while (choice == 'y' || choice == 'Y');

    //// Recursively call deleteEdgehelper with new inputs
    //deleteEdgehelper(graph, newSource, newDestination, newTransportation);
}